--

title:  "#3 - 운영체제 2-2장, CPU 스케줄러" 

excerpt: "스케줄러의 모든것"

categories:

  -  study

tags:

  - [study, 운영체제, OS]

last_modified_at: 2023-04-16

---


## 스케줄러의 필요성
 + CPU-I/O Burst Cycle : CPU가 동작하는 시간과 I/O가 실행되는 시간의 사이클
 + I/O 상태에서는 CPU가 동작하지 않기 때문에 좀더 효율적인 CPU 연산을 위해 스케줄링이 필수적이다.
 + 아래에서는 CPU 스케줄링에 대하여 다룬다.
 
 ## CPU 스케줄러
 + 다음과 프로세스 하나에 대하여 다음과 같은 상황에 스케줄러가 위치를 지정한다.
     1. Running 상태에서 Waiting 상태로 전환된 프로세스
     2. Running 상태에서 Ready 상태로 전환된 프로세스
     3. Waiting 상태에서 Ready 상태로 전환된 프로세스
     4. 완전히 종료된 프로세스
 + 작업들은 우선순위를 가지고 있으며 선점이 될 수도 있다.
 + 우선순위가 1에서 4인 작업은 비선점으로 항상 우선적으로 동작한다.
 + 나머지 작업들은 선점될수 있으며 우선순위에 따라 다시 평가된다.
 + 이런 우선순위 작업은 Ready Queue에서 주로 발생한다.

### Dispatcher
 + 디스패처는 Short-term 스케줄러에 의해 선택된 프로세스를 CPU에 할당하는 동작을 한다.
 + 디스패처는 커널 환경에서 동작한다.
 + 프로세스의 문맥을 교환하거나 유저모드로 변경시키고, 적절한 위치로 프로그램을 이동한다.
 + 문맥이 교환되거나 새로운 프로세스를 CPU에 할당할 때 발생하는 시간을 디스패치 레이턴시라고 한다.
 
 
 ## 스캐줄링 정책
 + 스케줄러는 정책에 따라 동작을 수행하며 다음의 특징을 가진다.
     + CPU 유틸리제이션 : CPU는 항상 바쁘게 동작해야한다.
     + 처리량(Throughput): 단위 시간단 처리하는 갯수를 정해야 한다.
 + 스케줄러는 3가지 시간적 특징을 가진다.
     + Turnaround Time : 작업이 전체 동작하는 시간
         + Ready - Run - Terminate - Ready 되는 전체 시간을 의미한다.
     + Waiting Time : 작업의 대기시간
         + Ready Queue 에서 대기하는 시간을 의미한다.
         + 짧은 작업을 우선하여 동작하면 최적의 정책이 된다.
     + Response Time : 전체 동작 중 가장 첫번째 결과가 나올 때 까지의 시간
         + 여러 작업들 중 가장 먼저 실행되는 결과 까지의 시간을 의미한다.
 + 은행 비유를 통해 위 시간들의 특징을 알아보자
     1. 은행 입장 후 번호표 뽑기 (Ready Queue)
     2. 번호가 될때 까지 대기 (Waiting Time)
         + 만약 다른 손님이 우선권을 가진 작업이 들어오면 선점당함
     3. 통장정리를 시작하고 한줄이 찍혔음 (Response Time)
     4. 모든 작업이 완료되고 은행을 나왔음 (Turn Around Time)
+ 스캐줄러는 상황에 따라서 conflict가 발생한다.
    + 상호작용이 중요한 시스템에서 Response Time을 중요시 했다면
    + Response Time이 강화되고 -> 문맥교환이 증가되며 -> 처리량이 감소된다.
    + 따라서 상호아에 맞는 적절한 스케줄링 정책이 요구된다.
+ CPU의 동작시간과 처리량을 극대화 하고 시간적 특징들을 최소로 하는 스케줄링 정책이 필요하다.

### First-Come, First-Served(FCFS) 방식
 + 거의 FIFO 방식과 동일하다.
 + 먼저 들어온 작업은 우선적으로 처리된다.
 + 따라서 비선점이고, 반드시 순서에 따라 처리된다.
 + 상당히 비효율적이고 최근에는 거의 사용되지 않는다.
 + 간트 차트를 참고해보자
 + 
 + 작업들의 순서에 따라 평균 대기시간이 달라지는 것을 확인 할 수 있다.
 + 이른 호위효과(Convoy Effect)라고 하며 FCFS가 비효율 적인 이유이다.

### Shortest-Job-First (SJF) 방식
 + 가장 짧은 작업을 우선적으로 처리한다.
 + 선점이나 비선점으로 동작될 수 있는데, 기본적으로 선점이다.
     + 비선점일 때 : 한번 CPU Burst 상태가 되면 해당 작업이 끝날때까지는 선점되지 못한다.
         + 사진
     + 선점일 때 : CPU Burst 상태에서 더 짧은 실행시간의 작업이 선점되며, Burst 중이던 동작은 그대로 대기한다.
         + 이를 Shortest-Remaining-Time-First(SRTF)라고 한다.
         + 사진
 + 그렇다면 실제로 Burst되는 시간은 어떻게 알 수있을까?
     + 동작해보지 않고서 Burst Time은 정확하게 알 수 없다.
     + 그러나 이전 CPU Burst Time을 기반으로 예측이 가능하다.
 + 다음 CPU Burst 예측하는 방법
     + 다음 CPU Burst = 가중치 상수 x 현재 실재로 실행된 Burst Time + (1 - 가중치 상수) x 앞에서 예측했던 현재 실행중인 작업의 Burst Time 예측값
     + τ next = α*T real + (1 - α) τ now
     + 가중치 상수 α는 0에 가까울 수록 실제 시간을 고려하지 않고, 1에 가까울수록 실제 실행시간만을 고려한다.
     + 따라서 0.5의 값을 가지면 실제 시간과 예측했던 시간을 적절히 사용가능하다.

### Priority Scheduling



<br>

    😺 오타나 논리적 오류 지적은 언제든지 환영합니다!😺   

    항상 읽어주셔서 감사합니다~ 🙏
